# pg-accessor

pg-accessor is a handy Node.js package for PostgreSQL databases that makes creating getter and setter functions for the tables a breeze. 

The getter and setter functions are built using the amazing [pg-promise][] package for async data management. Please refer to its [documentation][] if you want to know more about the functions that are generated by this package.

## Table of Contents
* [Installation](#installation)
* [Usage](#commands)
* [The config.js file](#the-config.js-file)
  + [1. getter {..}](#1.-getter-{..})
  + [2. setter {..}](#2.-setter-{..})
  + [3. Parameterized Values](#parameterized-values)
* [Examples](#examples)
* [Contributing](#contributing)
* [Contact](#contact)
* [License](#license)

## Installation
```bash
# For easiest use, install in global:
npm install -g pg-accessor 
# Usage: accessor <command>

# Local installation (relative path required):
npm install pg-accessor 
# Usage: ./node_modules/bin/accessor <command>
```
    
## Usage
The usage is pretty straightforward.
* First run `accessor init`. 
* This will create config.js file in the ./db folder.
* The config.js file consists of an object with various specifications that are easily customizable.
  + Refer [here](#the-config.js-file) to learn how.
* Once you're done customizing the config.js file, run `accessor build`. 
* This will generate getter and setter files with the specifications defined in config.js.

**Note** : It is recommended you use underscore in table names to seperate different words. Eg: _my_table_, _order_id_, etc.

## The config.js file
config.js consists a list of all your tables further broken down into getter and setter properties. These properties are further divided into required and optional properties. If one of the required child property is left empty, the parent property i.e. the getter or setter for that table will not be built.

To prevent the building of both&mdash;getter and setter&mdash;for certain tables, just delete the entire table object from the config.js file.<br>Similarly, to prevent the building of only one&mdash;either the getter or the setter&mdash;of a certain table, just delete the getter/setter objects of that table. Refer to the [examples](#examples) section to learn more.

Below are the general specificiations of various properties, and how you can use them.
### **1. getter {..}**
| Property |  Type  | Required |                                                                                              Description                                                                                              |
|:--------:|:------:|:--------:|:-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|   name   | String |    Yes   | The name of the getter function.<br>Autogenerated, but can be changed as desired.                                                                                                                     |
|  select  |  Array |    Yes   | The columns to be pulled from database.<br>By default contains all the columns in the table, but can delete the ones that are not required.<br>If all columns are required, just put an asterisk (*). |
|   from   | String |    Yes   | The name of the table you want to obtain the data from.<br>Autogenerated, but can be altered to use more complex tables like in case of joins.                                                        |
|   where  | Object |    No    | Conditions specified in form of key value pairs.<br>Eg: `{"name":"John", "id":123}`                                                                                                                   |

### **2. setter {..}**
| Property |  Type  | Required |                                                                                   Description                                                                                  |
|:--------:|:------:|:--------:|:------------------------------------------------------------------------------------------------------------------------------------------------------------------------------:|
|   name   | String |    Yes   | The name of the setter function.<br>Autogenerated, but can be changed as desired.                                                                                              |
|   base   | String |    Yes   | The name of the table you want to update the data in.                                                                                                                          |
|    set   | Object |    Yes   | The new values in the form of key-value pairs.<br>The keys are essentially the column names, and the values are the new data you want to put in that column.<br>Eg: `{"age":18}` |
|   where  | Object |    No    | Conditions specified in form of key value pairs.<br>Eg: `{"name":"John", "id":123}`                                                                                            |

### **3. Parameterized Values**
It is possible to create field values of the getter and setter function to be parameterized. These values will not be predefined, but will be sent as arguments to the getter or setter function during the time of execution of your program

To create a parameterized field, just use a dollar sign ($) followed by the variable name. For example, if you want to get username as an argument to the _WHERE_ clause of a getter function, just add the following to the "where" object: `username: $username`. Refer to [examples](#examples) section for better examples.

## Examples
#### 1. config.js of a database to generate getter and setter for (_USERS_) table.
The following will return all columns and rows for the getter; and will will update the age of a particular user using the user parameter to setter.
```javascript
// config.js
module.exports = {
  "USERS": {
    "getter": {
      "name": "getUsers", // Autogenerated
      "select": ["*"], // Was autogenerated with as ["id","user","age","city"], but changed it to ["*"].
      "from": "Users", // Autogenerated
      "where": {} // No condition clause
    },
    "setter": {
      "name": "setAge", // Was autogenerated as setUsers, but changed it to setAge
      "base": "Users", // Autogenerated
      "set": {
        "age": "$age" // Creating a parameter for age, that is to be sent to the setter function.
      },
      "where": {
        "user": "$user" // Like above creating a parameter for user
      }
    }
  }
}
```

**The resulting output files will look like:**
```javascript
// getUsers.js
const db = require('./index');

const QUERY = `SELECT * FROM Users`;

const getUsers = () => {
  return db.any(QUERY, [])
    .then((data) => {
      return data;
    }).catch((err) => {
      throw err;
    });
}
module.exports = getUsers;
```
```javascript
// setAge.js
const db = require('./index');

const QUERY = `UPDATE Users SET age=$1 WHERE user=$2`;

const setAge = (age,user) => {
  return db.query(QUERY, [age,user])
    .catch((err) => {
      throw err;
    });
}
module.exports = setAge;
```
<hr>

#### 2. config.js of a database to only generate a getter with a complex _FROM_ clause. 
The generated getter function will return the user's name and salary of the ones living in San Francisco, and of the age as passed as a parameter to the getter function.
```javascript
// config.js
module.exports = {
  "USERS": {
    "getter": {
      "name": "getSalary", // Was autogenerated to "getUsers", but changed to "getSalary".
      "select": ["user", "salary"], // Selecting user and salary columns
      "from": "users INNER JOIN employees ON users.id = employees.id", // Complex FROM clause
      "where": {
        "age": "$age", // age parameter
        "city": "San Francisco"
      }
    } // Setter was autogenerated after this, but because didn't deleted it because was not required.
  }
}
```
## Contributing
I really appreciate all the help that I can get, but following a few guidelines can go a long way in a hassle-free transition of your contributions into the project.

* Forking the main repository is always the best way to contribute and keep track of changes.
* Document your code, and try to follow the code style of the the base project.
* Auth Tokens, Access Codes, etc. should be loaded from environment variables, and should not appear anywhere in the code, nor should they be uploaded to the repository in any form.
* Always try and add as much description as possible with your pull requests. The following are few questions you could answer while writing the description:
  + What were you trying to do?
  + Were you successful in doing so?
  + If yes, briefly describe what you did.
  + Else, what do you think is the problem, and what all did you try to solve the problem?
* Your pull request should at least pass the placed build tests. Always double check that your changes do not break the main project. 

In case your pull-requests are not accepted, I will make sure to add a reason.

Please feel free to post issues and feature requests to the issue tab. If you have any other questions, you can contact me via email or Telegram.

## Contact
**Email** : uzair_inamdar@hotmail.com<br>
**Telegram** : @uzair_inamdar

## License
[MIT](LICENSE)


[pg-promise]: https://github.com/vitaly-t/pg-promise
[documentation]: https://github.com/vitaly-t/pg-promise/#documentation
